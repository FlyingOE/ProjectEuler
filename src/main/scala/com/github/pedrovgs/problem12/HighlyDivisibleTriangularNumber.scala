/*
 * Copyright (C) 2014 Pedro Vicente G칩mez S치nchez.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.github.pedrovgs.problem12

import com.github.pedrovgs.time.Time

/**
 *
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
 *
 * @author Pedro Vicente G칩mez S치nchez
 */
object HighlyDivisibleTriangularNumber {

  def main(args: Array[String]) {
    Time.measure(println("Largest product in the grid is: " + getTriangularNumberWithDivisors(500)))
  }

  /**
   * Calculate the triangle values from 1 using the formula triangleNumber = n * (n+1) / 2 inside an stream.
   * Once you have every triangle number from none we are going to find the trieangle number with more than
   * n divisors using getDivisors method.
   *
   * Get divisors method generates a range between 1 and Int.MaxValue to take just that numbers less than the
   * square of the number is less than the number to get divisors. Once you have a list of numbers we are going
   * to apply a fold left from 0 to search the divisors.
   *
   * Using fold left we are going over the selected values to count dividers.
   *
   * @param divisors
   * @return
   */
  def getTriangularNumberWithDivisors(divisors: Int): Int = {

    def getDivisorsCount(number: Int) = {
      (1 to Int.MaxValue)
        .takeWhile(n => n * n <= number)
        .foldLeft(0)((acc, n) => if (number % n == 0) acc + 2 else acc)
    }

    def triangles = Stream.from(1).map(n => n * (n + 1) / 2)
    triangles.find(getDivisorsCount(_) > divisors).get

  }

}
